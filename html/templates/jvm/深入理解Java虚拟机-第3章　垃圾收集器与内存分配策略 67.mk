## 第3章　垃圾收集器与内存分配策略 67
### 3.1　概述 67
### 3.2　对象已死？ 68
#### 3.2.1　引用计数算法 68
#### 3.2.2　可达性分析算法 70
#### 3.2.3　再谈引用 71
#### 3.2.4　生存还是死亡？ 72
#### 3.2.5　回收方法区 74
### 3.3　垃圾收集算法 75
#### 3.3.1　分代收集理论 75
#### 3.3.2　标记-清除算法 77
#### 3.3.3　标记-复制算法 78
#### 3.3.4　标记-整理算法 79
### 3.4　HotSpot的算法细节实现 81
#### 3.4.1　根节点枚举 81
#### 3.4.2　安全点 82
#### 3.4.3　安全区域 83
#### 3.4.4　记忆集与卡表 84
#### 3.4.5　写屏障 85
#### 3.4.6　并发的可达性分析 87
### 3.5　经典垃圾收集器 89
#### 3.5.1　Serial收集器 90
#### 3.5.2　ParNew收集器 92
#### 3.5.3　Parallel Scavenge收集器 93
#### 3.5.4　Serial Old收集器 94
#### 3.5.5　Parallel Old收集器 95
#### 3.5.6　CMS收集器 96
#### 3.5.7　Garbage First收集器 98
### 3.6　低延迟垃圾收集器 104
#### 3.6.1　Shenandoah收集器 105
#### 3.6.2　ZGC收集器 112
### 3.7　选择合适的垃圾收集器 121
#### 3.7.1　Epsilon收集器 121
#### 3.7.2　收集器的权衡 121
#### 3.7.3　虚拟机及垃圾收集器日志 122
#### 3.7.4　垃圾收集器参数总结 127
### 3.8　实战：内存分配与回收策略 129
#### 3.8.1　对象优先在Eden分配 130
#### 3.8.2　大对象直接进入老年代 131
#### 3.8.3　长期存活的对象将进入老年代 132
#### 3.8.4　动态对象年龄判定 134
#### 3.8.5　空间分配担保 135
### 3.9　本章小结 137
