<meta name="viewport" content="width=device-width, initial-scale=1" charset="utf-8">
<link rel="stylesheet" href="../Css/markdownCss/github-markdown.css">
<style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>
<div class="markdown-body " >
<h1>Beginning C ,Fifth Edition</h1>
<h4>前言 </h4>
<p>有抱负的程序员必将面对的三重障碍，遍布程序设计语言中的各类术语、理解如何使用语言元素（而不仅仅只是知道它们的概念）、领会如何在实际场景中应用该语言。</p>
<h4>第1章  C 语言编程</h4>
<h5>1.1  C 语言</h5>
<h5>1.2  标准库</h5>
<p>标准库定语了编写C程序时常常需要的常量、符号和函数。它还提供了基本C语言的一些可选扩展，标准库以不依赖及其的形式实现，即相同的C代码在不同的底层硬件上会实现相同的功能。</p>
<p>标准库在一系列文件——头文件中指定。头文件的扩展名总是.h。使用一组标准功能可用于C程序文件，只需要将队形标准头文件含进来。</p>
<h5>1.3  学习 C</h5>
<h5>1.4  创建 C 程序</h5>
<p>C 程序的创建工程有 4 个基本步骤：</p>
<ul>
<li>编辑</li>
<li>编译</li>
<li>链接</li>
<li>执行</li>
</ul>
<h5>1.4.1  编辑</h5>
<p>创建和修改 C 程序的源代码——我们编写的程序指令称之为源代码。</p>
<h5>1.4.2  编译</h5>
<p>编译器可以将源代码转换成机器语言，在编译过程中，会找到并报告错误。编译会生成对象代码，存放于对象文件它与源文件同名，这些文件在Windows中扩展名通常是 .obj,Linux中通常是.o</p>
<p>若编译器是GUN，编译命令是：</p>
<pre><code>gcc -c main.c
</code></pre>
<p>编译过程包括两个阶段：第一个阶段称为预处理阶段，在此期间会修改或添加代码。第二阶段是生成对象代码的实际编译过程。源文件可以包含预处理宏，他们用于添加或修改 C 语言程序。</p>
<h5>1.4.3  链接</h5>
<p>链接器（linker）将源代码文件中有编译器产生的各种对象模块组合起来，再从C语言提供的程序库中添加必要的代码块，将他们组合成一个可执行的文件，链接器也会检测和报告错误，可以将一个程序拆分成几个源代码文件，再用链接器连接起来，每个源文件提供部分功能，每个源文件分别编译。</p>
<p>链接阶段出现错误，意味着要重新编译源代码，链接成功则会产生一个可执行文件，但这并不意味着程序能正常工作。</p>
<h5>1.4.4  执行</h5>
<p>执行阶段就是当成功完成了前述 3 个过程后运行程序。</p>
<h5>1.5  创建第一个程序</h5>
<pre><code>#include &lt;stdio.h&gt;
 
 int main(void){
     printf(&quot;Hello world!&quot;);
     return 0;
 }
 
</code></pre>
<h5>1.6  编辑第一个程序</h5>
<pre><code>/* 注意 \&quot; ， \&quot;序列称之为转义序列（escape sequence）。 */
#include &lt;stdio.h&gt;
 
 int main(void){
     printf(&quot;Hello world!\n&quot;);
     return 0;
 }
 
</code></pre>
<h5>1.7  处理错误</h5>
<p>根据编译器提示，处理错误吧。</p>
<h5>1.8  剖析一个简单的程序</h5>
<h5>1.8.1  注释</h5>
<pre><code>多行注释：/*    */；无论 /* 之后的任何文本都会被认为是注释直到标示注释结束的 */ 为止。
单行注释：//；代码行上两个斜杠后面的所有内容都会被编译器忽略。
</code></pre>
<h5>1.8.2  预处理指令</h5>
<p>下面的代码行：</p>
<pre><code>#include &lt;stdio.h&gt;
</code></pre>
<p>符号 # 标示这是一个预处理指令（preprocessing directive），告诉编译器在编译源代码前，要先执行一些操作，编译器在编译过程开始前的预处理阶段处理这些指令，预处理指令相当多，大多数放于程序源文件的开头。</p>
<p>在这个例子中，编译器要将 stdio.h 文件的内容包含进来，这个文件称之为头文件（header file），因为它通常放在程序的开头出。在本例中，头文件定义了 C 标准库中的一些函数信息，通常，在头文件中指定的信息应有编译器用于在程序中集成预定义函数和其他全局对象，有时需要创建自己的头文件。本例中用到标准库中的printf()函数，所以必须包含 stdio.h 头文件。 stdio.h 头文件包含了编译器理解 printf() 以及其他输入/输出函数所需要的信息。名称 stdio 是标准输入/输出（standard input/output）的缩写。C 语言中石油的头文件的扩展名都是 .h 。</p>
<blockquote>
<p>注意：</p>
<p>    在一些系统中，头文件名是不区分大小写的，但在#include 指令里，这些文件名通常是小写。</p>
</blockquote>
<h5>1.8.3  定义 main() 函数</h5>
<p>下面的5行指令定义了main()函数：</p>
<pre><code> int main(void)
 {
     printf(&quot;Hello world!\n&quot;);
     return 0;
 }
</code></pre>
<p>函数是两个括号主键执行某组操作的一段代码，每个 C 程序都是由一个或多个函数组成，每个 C 程序都必须有个 main() 函数，main()函数是每个 C 程序的执行起点。在执行阶段执行可执行文件时，操作系统会执行这个程序的main()函数。</p>
<p>定义main()函数的第一行代码如下：</p>
<pre><code>int main(void)
</code></pre>
<p>定义main()函数的第一行代码开头是一个关键字 int，它标示main()函数的返回值类型。</p>
<p>在下面的语句中，指定了执行完 main()函数后要返回的值：</p>
<pre><code>return 0;
</code></pre>
<p>这个 return 语句结束了 main() 函数的执行。</p>
<p>函数名“main”后面的括号，是给函数main传递信息的入口，void 表示 给 main()函数传递的数据是无。</p>
<h5>1.8.4  关键字</h5>
<h5>1.8.5  函数体</h5>
<p>函数体是在函数名称后面起始及结束两个大括号之间的代码块。</p>
<p>每个函数必须有函数体，但函数体可以是空的。</p>
<h5>1.8.6  输出信息</h5>
<p>printf() 是一个标准的库函数，它会将给printf() 函数传递的信息输出到命令行上。</p>
<h5>1.8.7  参数</h5>
<p>包含在函数名后圆括号内的项称为参数，它是指要传递诶函数的数据，当一个函数有多个参数时，要用逗号隔开。</p>
<h5>1.8.8  控制符</h5>
<p>反斜杠( \ )在文本字符串里具有特殊意义，他表示转义序列的开始。反斜杠后面的字符表示是哪种转义序列。</p>
<p>表 1-1 是转义序列表：
<img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-12_183608.png" alt="image" /></p>
<h5>1.8.9  三字母序列</h5>
<p>这类转义序列存在的唯一原因是，有9个特殊的字母序列，称之为三字母序列，这是包含三个字母的序列，分别表示#、[、]、\、^、~、|、{和}：</p>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-12_185336.png" alt="image" /></p>
<p>在 International Organization of Standardization(ISO)不变的代码集中编写C代码时，需要用到它们，可以完全不用理会它们，使用三字母序列时，编译器会发出一个警告，因为通常是不应该使用三字母序列的。</p>
<h5>1.9  预处理器</h5>
<p>预处理指令可以把头文件的内容包含到源文件中。编译的预处理阶段可以做的工作远不止此，除了指令外，源文件还可以包含宏。宏是提供给预处理器的指令，来添加或修改程序中的 C 语句。宏可以很简单，只定义一个符号，例如 INCHES_PER_FOOT ，只要出现这个符号，就用 12 代替。其指令如下：</p>
<pre><code>#define  INCHES_PER_FOOT 12
</code></pre>
<p>在源文件中包含这个指令，则代码中只要出现 INCHES_PER_FOOT ，就用 12 替代它。例如：</p>
<pre><code>printf(&quot;Hello world!\n&quot;,INCHES_PER_FOOT);

</code></pre>
<p>在预处理后，这个语句变成：</p>
<pre><code>printf(&quot;Hello world!\n&quot;,12);

</code></pre>
<p>宏也可以很复杂，根据特定的条件把大量代码添加到源文件中。</p>
<h5>1.10  用 C 语言开发程序</h5>
<p>介绍编写程序时需要完成的基本步骤。</p>
<h5>1.10.1  了解问题</h5>
<p>了解需求，定义程序要解决的问题部分。</p>
<h5>1.10.2  详细设计</h5>
<p>讲需求分解为可管理的单元模块，描述这些独立模块互相沟通的方式。</p>
<h5>1.10.3  实施</h5>
<p>有计划的实施。</p>
<h5>1.10.4  测试</h5>
<h5>1.11  函数及模块化编程</h5>
<p>大多数编程语言都提供一种方法，将程序切割成多个段，各个段都可以独立编写。在 C 语言中这些段称之为函数。</p>
<p>每个函数都完成一个指定的、定义明确的工作，程序中操作的执行由一个main()总体掌控。</p>
<p>程序切割成多个易于管理的小单元，对编程非常重要。</p>
<h5>1.12  常见错误</h5>
<p>编译和连接报错好找，但是不报错缺得不到正确的结果才是头疼的。</p>
<h5>1.13  要点</h5>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-13_171407.png" alt="image" /></p>
<h4>第2章  编程初步</h4>
<p>在程序中仓储数据项的地方是可以变化的，叫做变量(variable)，这是本章的主题。</p>
<p><strong>本章的主要内容：</strong></p>
<ul>
<li>内存的用法及变量的概念</li>
<li>在 C 中如何计算</li>
<li>变量的不同类型及其用途</li>
<li>强制类型转换的概念及其使用场合</li>
<li>编写一个程序，计算树木的高度</li>
</ul>
<h5>2.1  计算机的内存</h5>
<p>计算机执行程序时，组成程序的指令和程序操作的数据都必须存储到某个地方。这个地方就是机器的内存，也称之为主内存(main memory)，或随机访问存储器(Random Access Memory, RAM)，RAM是易失性存储器。关闭 PC 后，RAM 的内容就会丢失。PC 把一个或多个磁盘驱动器作为其永久存储器。要在程序结束执行后存储起来的任何数据，都应该写入磁盘。</p>
<p>计算机用二进制存储数据：0 或 1.计算机有时用真(true)和假(false)表示它们：1 是真，0 是假。每一个数据称之为一个位(bit),即二进制数(binary digit)的缩写。</p>
<p>内存中的位以 8 个为一组，没组的 8 位称之为一个字节(byte)。为了使用字节的内容，每个字节用一个数字表示，第一个字节用 0 表示，第二个字节用 1 表示，直到计算机内存的最后一个字节。字节的这个数字标记称之为字节的地址(address)。因此，每个字节的地址都是唯一的。字节的地址唯一地表示计算机内存中的字节。</p>
<p>总之，内存的最小单位是位(bit)，将8个位组合为一组，称之为字节(byte)。每个字节都有唯一的地址。字节的地址从 0 开始。位只能是 0 或 1 ，如图所示：</p>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-13_182303.png" alt="image" /></p>
<p>计算机的内存的常用单位是千字节(KB)、兆字节(MB)、千兆字节(GB)。磁盘驱动器还使用兆兆字节(TB)。这些单位的大小如下：</p>
<ul>
<li>1KB 是1024 字节。</li>
<li>1MB 是1024 KB，也就是1 048 576 字节。</li>
<li>1GB 是1024 NB，也就是1 072 741 841 字节。</li>
<li>1TB 是1024 GB，也就是1 099 511 627 776 字节。</li>
</ul>
<p>如果 PC 有 1GB 的 RAM ，字节地址就是0~1 073 741 841 。0 到 1023 共 1024 个数字(1 byte ,8位)，MB 需要 20 个位，GB 需要 30 个位，</p>
<h5>2.2  什么是变量</h5>
<p>变量时计算机里一块特定的内存，它是由一个或多个连续的字节组成，一般是1、2、4、8 或 16 字节。每个变量都有一个名称，可以用该名称表示内存的这个位置，以提取它包含的数据或存储一个新的数值。</p>
<p><strong>变量的命名</strong></p>
<p>给变量指定名称一遍称为变量名。变量的命名是很有弹性的。可以由：字母、数字、下划线（_）组成，要以字母开头。以一或两个下划线开头的变量名常用字头文件中，所以在源代码中给变量命名时，不要讲下划线作第一个字符，以免和标准库里的变量名冲突。变量名的另一个要点是，变量名是区分大小写的。</p>
<blockquote>
<p><strong>警告：</strong></p>
<p>    变量名可以包含的字符数取决于编译器，遵循 C 语言标准的编译器至少支持 31 个字符，只要不超过这个程度就没问题。有些编译器会截短过长的变量名。</p>
</blockquote>
<h5>2.3  存储整数的变量</h5>
<pre><code>int salary ;
</code></pre>
<p>这个语句称为变量声明，因为它声明了变量的名称，在这里，变量名是 salary。</p>
<p>变量声明也指定了这个变量存储的数据类型。这里使用关键字 int 指定 salary 用来存放一个整数。</p>
<p>变量声明也称为变量的定义，因为它分配了一些存储空间，来存储整数数值，该整数可用变量名 salary 来引用。</p>
<p><strong>注意：</strong></p>
<p>声明引入了一个变量名，定义则给变量分配了存储空间，有这个区别的原因在本书后面会很清楚。</p>
<p>现在还未指定变量 salary 的值 ，所以此刻该变量包含一个垃圾值，即上次使用这块内存空间时遗留在此的值。</p>
<p>下一个语句是：</p>
<pre><code class="language-c">salary = 10000;
</code></pre>
<p>这是一个简单的算数赋值语句，它将等号右边的数值存储到等号左边的变量中。</p>
<p>等号“=”称为赋值运算符，它将右边的值赋予左边的变量。</p>
<p>然后是熟悉的 printf() 语句，但它有两个参数：</p>
<pre><code>printf(&quot;My salary is %d.&quot;,salary);
</code></pre>
<ul>
<li>参数1：控制字符串，用来控制气候的参数输出以书面方式显示，它是放在双引号内的字符串，也称为格式字符串，因为它制定了输出数据的格式。</li>
<li>参数2：是变量名 salary，这个变量的显示方式由第一个参数——控制字符串来确定。</li>
</ul>
<p>在控制字符串在有个 %d，它称为变量值的转换说明符（conversion specific）。</p>
<p>转换说明符确定变量在屏幕上显示的方式，换言之，他们制定最初的二进制值转换为什么形式，显示在屏幕上。在本列中使用了 d，它是应用于整数值的十进制说明符，表示第二个参数salary输出为一个十进制数。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>    转换说明符总是以 % 字符开头，以便 printf()函数识别出它们。所以如果要输出 % 字符，就必须用转义序列 %%。</p>
</blockquote>
<p>控制字符串可以存在多个转换说明符，例如：</p>
<pre><code>int brides = 5;
int brothers = 10;
printf(&quot;%d My salary is %d .&quot;,brides,brothers);
</code></pre>
<p>在一个语句中声明多个同类型的变量时，可以用逗号将数据类型后面的变量名分开。例如：</p>
<pre><code>int brides ,brothers ;

int brides2 ,
    brothers2 ;
</code></pre>
<h5>2.3.1  变量的使用</h5>
<p>下面的代码展示了将两个整数变量进行计算并赋值个变量 a 。</p>
<pre><code>int brides = 5;
int brothers = 10;
int a = brides + brothers;
printf(&quot; My salary is %d .&quot;,a);
</code></pre>
<h5>2.3.2  变量的初始化</h5>
<p>变量的声明：</p>
<pre><code>int salary ;
</code></pre>
<p>此时变量的值是上一个程序在那块内存中留下的数值，它可以是任何数。</p>
<p>变量的初始化：</p>
<pre><code>salary = 10 ;
</code></pre>
<p>最好在声明变量时就对其进行初始化：</p>
<pre><code>int salary = 10 ;
</code></pre>
<p><strong>1、基本算数运算</strong>
在 C 语言中，算数语句的格式如下：</p>
<pre><code>变量名 = 算数表达式；
</code></pre>
<p>赋值运算符右边的算数表达式指定使用变量中存储的值或者直接的数字，以算术运算符如加（+）、减（-）、乘（*）、除（/）、取模（%）等运算符进行计算。例如：</p>
<pre><code>int brides = 5;
int brothers = 10;
int a = brides + brothers + 5 ;
</code></pre>
<p>赋值运算先计算赋值运算符右边的算数表达式，再将所得结果赋值到左边的变量中。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>    应用运算符的值称为操作数。需要两个操作数的运算符(如%)称为二元运算符。应用于一个值的运算符称为一元运算符。因此-在表达式a-b中是二元运算符,在表达式-data中是一元运算符。</p>
</blockquote>
<p>如果两个或多个字符串彼此相邻,编译器会将它们连接起来,构成一个字符串。</p>
<p>例如：</p>
<pre><code>    int a = 10;
    int b = 20;
    printf(&quot;字符串1!%d \n-- \n&quot;&quot;字符串2!%d&quot;, a, b);
    //或者
    printf(&quot;字符串1!%d \n-- \n&quot;
    &quot;字符串2!%d&quot;,
     a, b);

</code></pre>
<h5>2.4  变量和内存</h5>
<p>每次声明给定类型的变量时，编译器都会给他分配一个足够大的内存空间，来保存该类型的变量。相同类型的不同变量占据相同打下ode内存空间（字节数）。不同类型的变量分配的内存空间就不一样了。整数变量还有几个不同的变体，以储存不同范围的整数。</p>
<h5>2.4.1  带符号的整数类型</h5>
<p>有 5 种基本的变量类型可以声明为存储带符号的整数值，如下表所示：</p>
<table>
<thead>
<tr><th>类型名称</th><th>字节数</th></tr>
</thead>
<tbody>
<tr><td>signed int</td><td>1</td></tr>
<tr><td>short int</td><td>2</td></tr>
<tr><td>int</td><td>4</td></tr>
<tr><td>long int</td><td>4</td></tr>
<tr><td>long long int</td><td>8</td></tr>
</tbody>
</table>
<p>类型名称 short、long、和long long 可以用作 short int 、long int 和 long long int 的缩写。这些变量类型所占据的内存空间，及可以存储的取值范围，取决于所使用的编译器。很容易确定编译器允许的极限值，因为它们在 limits.h 头文件中定义。</p>
<h5>2.4.2  无符号的整数类型</h5>
<p>对于每个存储带符号整数的类型，都有一个对应的类型来存储无符号的整数，它们占用的内存空间与无符号类型相同。每个无符号的类型名称都与带符号的类型名称相同，但要在前面加上关键字 unsigned 。</p>
<table>
<thead>
<tr><th>类型名称</th><th>字节数</th></tr>
</thead>
<tbody>
<tr><td>unsigned signed int</td><td>1</td></tr>
<tr><td>unsigned short int</td><td>2</td></tr>
<tr><td>unsigned int</td><td>4</td></tr>
<tr><td>unsigned long int</td><td>4</td></tr>
<tr><td>unsigned long long int</td><td>8</td></tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：</strong></p>
<p>    如果变量的类型不同，但占用相同的字节数，则它们仍是不同的。Long 和 int 类型占用相同的内存量，但它们扔是不同的类型。</p>
</blockquote>
<h5>2.4.3  指定整数常量</h5>
<p>整数变量有不同的类型,整数常量也有不同的类型。例如,如果将整数写成100,它的类型就是int。如果要确保它是long类型,就必须在这个数值的后面加上一个大写L或小写l。所以, long类型的整数100应写为100L。虽然写为100l也是合法的,但应尽量避免,因为小写字母l与数字1很难辨别。</p>
<p>例如：</p>
<pre><code>
// 指定为 long 类型。
long Big_Number = 123456L;

// 指定为 long long 类型。
long long Big_Number = 123456LL;

// 指定为 无符号类型 类型。
unsigned int Big_Number = 123456U;
unsigned long Big_Number = 123456UL;


</code></pre>
<p><strong>1、十六进制常量</strong></p>
<p>也可以用十六进制编写整数,即以16为基底。十六进制的数字等价于十进制的0~15表示方式是0~9和A~F(或a~f)。因为需要一种方式区分十进制的99和十六进制的99,所以在十六进制数的前面加上0x或0X。因此在程序中,十六进制的99可以编写成0x99或0X99,十六进制常量也可以有后缀。下面是十六进制常量的一些示例:</p>
<pre><code>0xFFFF  0xdead  0xfade  0xFade  0x123456EE  0xafL  0xFABABULL 
</code></pre>
<p>最后一个示例的类型是 unsigned long long，倒数第二个示例的类型是 long。</p>
<p>十六进制常量常用来表示位模式,因为每一个十六进制的数对应于4个二进制位。两个十六进制的数指定一个字节。第3章介绍的按位运算符一般与十六进制常量一起用于定义掩码。如果不熟悉十六进制,可以参阅附录A..</p>
<p><strong>2、八进制常量</strong></p>
<p>八进制数以 8 为基底。八进制数字为0~7,对应于二进制中的3位。八进制数起源于计算机内存采用 36 位字的时代,那时一个字是 3 位的组合。因此, 36 位二进制字可人写成 12 个八进制数。八进制数目前很少使用,需要知道它们,以免错误地指定八进制数。</p>
<p>以 0 开头的整数常量,例如 014,会被编译器看作八进制数。因此, 014 等价于十进制的12,而不是十进制的 14,所以,不要在整数中加上前导 0 ,除非要指定八进制数。很少需要使用八进制数。</p>
<p><strong>3、默认的整数常量类型</strong></p>
<p>如前所述,没有后缀的整数常量默认为 int 类型,但如果该值太大,在 int 类型中放不下,该怎么办?对于这种情形,编译器创建了一个常量类型,根据值是否有后缀,来判断该值是否是十进制。表2-5列出了编译器如何判断各种情形下的整数类型。</p>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-23_165447.png" alt="image" /></p>
<p>编译器选择容纳该值的第一种类型,如表中各项的数字所示。例如,后缀为 u 或 U 的十六进制常量默认为 unsigned int,否则就是 unsigned long。如果这个取值范围太小,就采用 unsigned long long 类型。当然,如果给变量指定的初始值在变量类型的取值范围中放不下,编译器就会发出一个错误消息。</p>
<h5>2.5  使用浮点数</h5>
<p>浮点数包含的值带小数点，也可以表示分数和整数。例如：</p>
<pre><code>1.6     0.00008     7655.899        100.0
</code></pre>
<p>由于浮点数的标示方式，她位数是固定的。这回限制浮点数的精度，是一个缺点。
浮点数通常表示为一个小数乘以 10 的次方。例如：</p>
<pre><code>数值          指数表示法           在 C 语言中
1.6          0.16 * 10^1            0.16E1
</code></pre>
<p>在 C 语言中的标示法，这些数字中的 E 标示指数，也可以使用 e 。对于小数位非常多的数，指数形式比较方便。0.5E-15当然比 0.0 000 000 000 000 005 更好。</p>
<p><strong>浮点数的表示</strong></p>
<p>下图显示显示了在 Intel PC 的内存中，浮点数是如何存储在 4 字节的内存中。</p>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2019-04-29_104931.png" alt="image" /></p>
<p>这是个单精度的浮点数，在内存中占用4个字节。该值包含三部分：</p>
<ul>
<li>符号位 Sign（1bit）：表示浮点数是正数还是负数。0表示正数，1表示负数</li>
<li>8 位的指数 Exponent（8bits）：指数部分。类似于科学技术法中的M*10^N中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中是以2^7-1即127，也即01111111代表2^0，转换时需要根据127作偏移调整。</li>
<li>23 位的尾数 Mantissa（23bits）：基数部分。浮点数具体数值的实际表示。 1&lt;= M &lt;2</li>
</ul>
<p>尾数部分包含浮点数中的小数，占用23位。它假定一个形式为 1.bbbbb...b 的二进制值，二进制点的右边有 23 位。因此尾数的值总是大于等于 1，小于 2。那么如何把 24 位值放在 23 位中，其实很简单。最左边的一位总是 1 ，所以不需要存储，采用这种方式，可以给精度提供一个额外的二进制数字。</p>
<p>指数是一个无符号的8位值，所以指数的值可以是 0~255。浮点数的实际值是尾数乘以 2的指数幂 2^exp ,其中 exp 是指数值。使用负的指数值可以表示很小的分数。为了包含这个浮点数表示。给浮点数的实际指数加上127，这将允许把-127~128的值表示为 8位无符号值。因此指数为 -6 会存储为 121 ，指数6会存储为133.单还有几个复杂的问题。</p>
<p><strong>浮点数由 10 进制改为 2 进制</strong></p>
<p>根据国际标准IEEE（电气和电子工程协会）规定，任何一个浮点数NUM的二进制数可以写为：
NUM = (-1)^S * M * 2^E ;(S表示符号，E表示阶乘，M表示有效数字)</p>
<blockquote>
<p>将10进制小数改为内存中的浮点数过程：</p>
<ul>
<li>
<p>1、改写整数部分：
以数值 5.375 为例。先不考虑指数部分，我们先单纯的将十进制数改写成二进制。
整数部分很简单，5.即101.。</p>
</li>
<li>
<p>2、改写小数部分：
小数部分我们相当于拆成是2^-1一直到2^-N的和。例如：0.375 = 0.25+0.125即2^-2+2^-3 ，也即.011。</p>
</li>
<li>
<p>3、拼接及转变为二进制科学计数法：5.375 = 101.011 = -1^0 * 1.01011 * 2^2</p>
</li>
<li>
<p>4、S = 0 , M = 01011 , E = 2 + 127 = 129 = 10000001</p>
</li>
<li>
<p>5、放入内存并补位：0 10000001 01011000000000000000000</p>
</li>
</ul>
</blockquote>
<pre><code>关于一个整数及小数转为 2 进制的简便示例：
1、整数部分除以 2 记录余数，将结果继续除 2 记录余数 ，直至结果小于 1 。
2、小数部分乘以 2 记录结果的整数部分，将结果的小数部分继续乘以 2 ，直至结果的小数部分是 0 。

NUM = 134.375

整数 134                             小数 0.375
134 / 2 = 67 余 0                    0.375 * 2 = 0.750   0
67 / 2 = 33  余 1                    0.750 * 2 = 1.5     1
33 / 2 = 16  余 1                    0.5 * 2 = 1.0       1
16 / 2 = 8   余 0
8 / 2 = 4    余 0
4 / 2 = 2    余 0
2 / 2 = 1    余 0
1    = 1     余 1
134 = 10000110                      0.375 = 0.25 + 0.125 = 2^-2 + 2^-3 = 0.011

//这是对二进制数的科学计数法
10000110.011 = -1^0 * 1.0000110011 * 2^7

S = 0,  M = 0000110011……,   E = 7 + 127 = 134 = 10000110

S    E          M
0 10000110 00001100110000000000000
</code></pre>
<p><strong>浮点数中的保留数</strong></p>
<p>因为会给 浮点数的实际指数加上 127，实际指数为 -127 ，而存储的的指数是 0，这是一种特殊情况。浮点数 0 表示为尾数和指数所有为都是 0 ，所以指数为 -127 时，不能用于其他的值。</p>
<p>0 11111111 00000000000000000000000 不是 1 * 2^128 ，且所有尾数位是 0 。负数除以 0 的结果是这个值取负，所以 -1 * 2^128 也是一个特殊值</p>
<p>对于E还分为三种情况：
①E不全为0，不全为1:
这时就用正常的计算规则，E的真实值就是E的字面值减去127（中间值)，M的值要加上最前面的省去的1。
②E全为0
这时指数E等于1-127为真实值，M不在加上舍去的1，而是还原为0.xxxxxxxx小数。这样为了表示0，和一些很小的整数。
所以在进行浮点数与0的比较时，要注意。
③E全为1
当M全为0时，表示±无穷大（取决于符号位）；当M不全为1时，表示这数不是一个数（NaN）</p>
<p>保留数：0
S = 0,E = 全是0，M = 全是0，
0 00000000 0000000000000000000000</p>
<p>保留数：0.
S = 0,E = 全是0，M = 不全是1，
0 00000000 0000000000000000000000</p>
<p>保留数：±无穷大 = 正数或负数 / 0
S = 0或1,E = 全是1，M = 全是0，
0 11111111 00000000000000000000000
1 11111111 00000000000000000000000</p>
<p>保留数：Not a Number(NaN) = 0 / 0
S = 0或1,E = 全是1，M = 1 或者 0，（尾数的首位是 1 或者 0 ，取决于 NaN 只是个 NaN，允许继续执行，还是一个发出信号的 NaN，在代码中生成一个可中断执行的异常。）
0 11111111 1……
1 11111111 01……（当前导数为0时，其他尾数至少有一个是1，以根无穷大区分）</p>
<blockquote>
<p>23位二进制数：11111111111111111111111 转化为十进制数是 8388607 ，十进制浮点数转化为二进制的浮点数时因为位移影响所以：二进制的浮点数整数位会影响其小数位的长度。
例如一个十进制浮点数的整数部分极大，其转化为二进制时二进制数的整数部分也极大，需向左位移位数较多，影响其原小数位精度</p>
</blockquote>
<h5>2.6  浮点数变量</h5>
<p>浮点数变量类型只能存储浮点数。下表 2-6 是 3 种不同的浮点数变量。</p>
<table>
<thead>
<tr><th>关键字</th><th>字节数</th><th>数值范围</th></tr>
</thead>
<tbody>
<tr><td>float</td><td>4</td><td>±3.4E±38（精确到 6 到 7 位小数）</td></tr>
<tr><td>double</td><td>8</td><td>±1.7E±308（精确到 15 位小数）</td></tr>
<tr><td>long double</td><td>12</td><td>±1.19E±38（精确到 18 位小数）</td></tr>
</tbody>
</table>
<p>这是浮点数类型通常占用的字节数和取值范围。与整数一样,这些数所占用的字节数和取值范围取决于机器和编译器。在一些编译器上,类型 long double 和 double 相同。注意,小数的精确位数只是一个大约的数,因为浮点数在内部是以二进制方式存储的十进制的浮点数在二进制中并不总是有精确的表示形式。</p>
<p>如果需要存储至多有 7 位精确值的数(范围从10^-38到10^38),就应需要使用 float 类型的变量。类型 float 的值称为单精度浮点数。从表 2-6 中得知,它占用4个字节。使用类型 double 的变量可以存储双精度浮点数。类型 double 的变量占用 8 个字节,有 15 位精确值,范围从10^-308到10^+308,它足以满足大多数的需求。</p>
<p>编写一个类型为 float 的常量,需要在数值的末尾添加一个 f ,以区别 double 类型。</p>
<pre><code>float redius = 2.5f;
double biggest = 123E30;
</code></pre>
<p>变量 radius 的初值是 2.5,变量 biggest 初始化为 123 后面加 30 个零。任何数,只要有小数点,就是 double 类型,除非加了 f,使它变为 float 类型。当用E或e指定指数值时,这个常量就不需要包含小数点。例如1E3f 是 float 类型, 3E8 是 double 类型。要声明 1ong double 类型的常量,需要在数字的末尾添加一个大写 L 或小写 l,例如:</p>
<pre><code>long double biggest = 1234567.89123L;
</code></pre>
<h5>2.6.1  使用浮点数完成除法运算</h5>
<p>使用整数操作数进行除法运算时,通常会得到整数结果。除非除法运算的左操作数刚好是右操作数的整数倍,否则其结果是不正确的。在无法整除时，这时就需要用到浮点数了。使用浮点数进行除法运算,会得到正确的结果——至少是一个精确到固定位数的值。</p>
<p>使用格式说明符 %f 显示浮点数。格式说明符一般必须对应输出的值的类型。如果使用格式说明符 %d 输出 float 类型的值,就会得到一个垃圾值。因为浮点数会解释为整数,同样,如果使用 % 输出整数类型的值,也会得到垃圾值。</p>
<h5>2.6.2  控制输出中的小数位数</h5>
<p>例如,要使输出的小数点后有两位数,可以使用格式说明符 %.2f。如果小数点后需要有 3 位数,则可以使用 %.3f。</p>
<h5>2.6.3  控制输出中的字段宽度</h5>
<p>输出的字段宽度是输出值所使用的总字符数(包括空格),在这个程序中,它是默认的。printf()函数确定了输出值需要占用多少个字符位置,小数点后的位数由我们指定并将它用作字段宽度。但我们可以自己确定字段宽度,也可以自己确定小数位数。如果要求输出一列排列整齐的数值,就应确定固定的字段宽度。如果让printr()函数指定字段宽度,输出的数字列就不整齐。用于浮点数的格式说明符的一般形式是:</p>
<pre><code>%[width] [.precision] [modifier]f
</code></pre>
<p>其中,方括号不包含在格式说明符中。它们包含的内容是可选的,所以可省略 width, .precision 或 modifier,或它们的任意组合。width 值是一个整数,指定输出的总字符数(包括空格),即字段宽度。precision 值也是一个整数,指定小数点后的位数。当输出类型是 long double 时, modifier 部分就是 L，否者就忽略它。</p>
<blockquote>
<p>我试了下，感觉 width 感觉没用啊。。。。。。</p>
</blockquote>
<p>指定字段宽度时,数值默认为右对齐。如果希望数值左对齐,只需要在 % 的后面添加一个负号。例如,格式说明符%-10.4f将输出一个左对齐的浮点数,其字段宽度为10个字符,小数点后有4位数。</p>
<p>注意,也可以对整数值指定字段宽度及对齐方式。例如 %-15d 指定一个整数是左对齐,其字段宽度为 15 个字符。还有其他格式说明符,以后会学习它们。</p>
<h5>2.7  较复杂的表达式</h5>
<p>对于较复杂的计算,需要更多地控制表达式的计算顺序。括号可以提供这方面的能力。当遇到错综复杂的情况时,括号还有助于使表达式更清晰。可以加入空格,将操作数和运算符分开,使算术表达式的可读性更高。</p>
<p><strong>函数：scanf(&quot;%f&quot;, &amp;b);</strong></p>
<pre><code>scanf(&quot;%f&quot;,&amp;diameter);
</code></pre>
<p>scanf()是另一个需要包含头文件 stdio.h 的函数。它专门处理键盘输入,提取通过键盘输入的数据,按照第一个参数指定的方式解释它,第一个参数是放在双引号内的一个控制字符串。在这里,这个控制字符串是 %f.因为读取的值是float类型。scanf()将这个数存入第二个参数指定的变量 diameter 中。第一个参数是一个控制字符串,和 print()函数的用法类似,但它控制的是输入,而不是输出。第10章将详细介绍 scanf()函数,附录 D总结了所有的控制字符串。</p>
<p>注意,变量名 diameter 前的 &amp; 是个新东西,它称为寻址运算符,它允许 scanf() 函数将读入的数值存进变量 diameter.它的做法和将参数值传给函数是一样的。这里不详细解释它;第8章会详细说明。唯一要记住的是,使用函数 scanf() 时,要在变量前加上寻让运算符 &amp; ,而使用 print() 函数时不添加它。</p>
<p>在函数 scanf()的控制字符串中, % 字符表示某数据项的格式说明符的开头。% 字符后面的 f 表示输入一个浮点数。在控制字符串中一般有几个格式说明符,它们按顺序确定了函数中后面各参数的数据类型。在 scanf() 的控制字符串后面有多少个参数,控制字符串就有多少个格式说明符,本书的后面将介绍 scanf() 函数的更多运用,表 2-8 列出了卖取各种类型的数据时所使用的格式说明符:</p>
<p>表 2-8</p>
<table>
<thead>
<tr><th>操作</th><th>需要控制的字符串</th></tr>
</thead>
<tbody>
<tr><td>读取 short 类型的数值</td><td>%hd</td></tr>
<tr><td>读取 int 类型的数值</td><td>%d</td></tr>
<tr><td>读取 long 类型的数值</td><td>%ld</td></tr>
<tr><td>读取 float 类型的数值</td><td>%f 或者 %e</td></tr>
<tr><td>读取 double 类型的数值</td><td>%lf 或者 %le</td></tr>
</tbody>
</table>
<h5>2.8  定义命名常量</h5>
<p>一个值在程序中保持不变可以设为常量。</p>
<p>这有两种方法：第一种是定义一个符号，在程序编译期间取代它。</p>
<pre><code>#include &lt;stdio.h&gt;
#define PI 3.1415926f

int main(void) {
    float a = 1000000000.000f;
    float b = 20.0f * PI;
    printf(&quot;你好&quot;);
    scanf(&quot;%f&quot;, &amp;b);

    printf(&quot;数值 a ——&gt; %5.2f \n-- \n&quot;&quot;数值 b ——&gt; %f&quot;, a, b);
    return 0;
}

</code></pre>
<p>在注释和头文件的#include指令之后,有一个预处理指令:</p>
<pre><code>#define PI 3.1415926f
</code></pre>
<p>这里将PI定义为一个要被 3.14159f 取代的符号。使用 PI 而不是 Pi ,是因为在 C 语言中有一个通用的约定: #define 语句中的标识符都是大写。只要在程序里的表达式中引用 PI,预处理器就会用 #define 指令中的数值取代它。所有的取代动作都在程序编译之前完成。程序开始编译时,不再包含PI这个符号了,因为所有的PI都用 #define 指令中的数值取代了。这些动作都是在编译器处理时在内部发生的,源程序没有改变,仍包含符号 PI.</p>
<blockquote>
<p><strong>警告：</strong></p>
<p>    在预处理器在替代代码中的符号时,不会考虑它是否有意义。如果在替代字符串中出错,例如,如果编写了3.14.159f,预处理器仍会用它替代每个PI,而程序不会编译。</p>
</blockquote>
<p>第二种方法是将 Pi 定义成变量,但告诉编译器,它的值是固定的,不能改变。声明变量时,在变量名前加上 const 关键字,可以固化变量的值,例如:</p>
<pre><code>    const float b = 3.1415926f;
</code></pre>
<p>以这种方式定义 Pi 的优点是, Pi 现在定义为指定类型的一个常量值。在前面的例子中, PI 只是一个字符序列,替代代码中的所有 PI 。</p>
<p>在 Pi 的声明中添加关键字 const,会使编译器检查代码是否试图改变它的值。这么做的代码会被标记为错误,且编译失败。</p>
<h5>2.8.1  极限值</h5>
<p>当然,一定要确定程序中给定的整数类型可以存储的极限值。如前所述,头文件 &lt;limits.h&gt;定义的符号表示每种类型的极限值。表2-9列出了对应于每种带符号整数类型的极限值符号名。</p>
<p>表2-9 整数类型的极限值的符号</p>
<table>
<thead>
<tr><th>类型</th><th>下限</th><th>上限</th></tr>
</thead>
<tbody>
<tr><td>char</td><td>CHAR_MIN</td><td>CHAR_MAX</td></tr>
<tr><td>short</td><td>SHORT_MIN</td><td>SHORT_MAX</td></tr>
<tr><td>int</td><td>INT_MIN</td><td>INT_MAX</td></tr>
<tr><td>long</td><td>LONG_MIN</td><td>LONG_MAX</td></tr>
<tr><td>long long</td><td>LLONG_MIN</td><td>LLONG_MAX</td></tr>
</tbody>
</table>
<p>无符号整数类型的下限都是 0,所以它们没有特定的符号。无符号整数类型的上限的符号分别是 UCHAR_MAX,USHRT_MAX、UINT_MAX、ULONG_MAX 和 ULLONG_MAX。</p>
<p>要在程序中使用这些符号,必须在源文件中添加 &lt;limits.h&gt; 头文件的 #include 指令：</p>
<pre><code>#include &lt;limits.h&gt; 
</code></pre>
<p>初始化最大值 int 变量，如下所示：</p>
<pre><code>//这个语句把number的值设置为最大值,编译器会利用该最大值编译代码。
int number = INT_MAX;
</code></pre>
<p>&lt;float.h&gt;头文件定义了表示浮点数的符号,其中一些的技术含量很高,所以这里只介绍我们感兴趣的符号。 3 种浮点数类型可以表示的最大正值和最小正值如表2-10所示。还可以使用FLT_DIG、DBL_DIG 和 LDBL_DIG符号,它们指定了对应类型的二进制尾数可以表示的小数位数。下面用一个例子来说明如何使用表示整数和浮点数的符号。</p>
<p>表2-10 表示浮点数类型的极限值的符号</p>
<table>
<thead>
<tr><th>类型</th><th>下限</th><th>上限</th></tr>
</thead>
<tbody>
<tr><td>float</td><td>CHAR_MIN</td><td>CHAR_MAX</td></tr>
<tr><td>double</td><td>SHORT_MIN</td><td>SHORT_MAX</td></tr>
<tr><td>long double</td><td>INT_MIN</td><td>INT_MAX</td></tr>
</tbody>
</table>
<pre><code>// Program 2.11 Finding the limits 
#include &lt;stdio.h&gt;// For command line input and output
#include &lt;limits.h&gt;//For limits on integer types
#include &lt;float.h&gt;// For limits on floating-point types
int main(void) {

    printf (&quot;Variables of type char store values from %d to %d\n&quot;, CHAR_MIN, CHAR_MAX);
    printf (&quot;Variables of type unsigned char store values from O to %u\n&quot;, UCHAR_MAX);
    printf (&quot;Variables of type short store values from %d to %d\n&quot;, SHRT_MIN, SHRT_MAX);
    printf (&quot;Variables of type unsigned short store values from o to %u\n&quot;, USHRT_MAX) ;
    printf (&quot;Variables of type int store values from %d to %d\n&quot;, INT_MIN, INT_MAX);
    printf (&quot;Variables of type unsigned int store values from o to %u\n&quot;, UINT_MAX) ;
    printf (&quot;Variables of type long store values from %ld to %ld\n&quot;, LONG_MIN, LONG_MAX) ;
    printf (&quot;Variables of type unsigned long store values from o to %lu\n&quot;, ULONG_MAX) ;
    printf (&quot;Variables of type long long store values from %lld to %lld\n&quot;, LIONG_MIN, LLONG_MAX);
    printf (&quot;Variables of type unsigned long long store values from 0 to %llu\n&quot;, ULLONG_MAX);

    printf (&quot;\nThe size of the smallest positive non-zero value of type float is %.3e\n&quot;, FLT_MIN);
    printf (&quot;The size of the largest value of type float is %.3e\n&quot;, FLT_MAX);
    printf (&quot;The size of the smallest non-zero value of type double is %.3e\n&quot;, DBL_MIN) ;
    printf (&quot;The size of the largest value of type double is %.3e\n&quot;, DBL_MAX) ;
    printf (&quot;The size of the smallest non-zero value of type long double is %.3Le\n&quot;, LDBL_MIN);
    printf (&quot;The size of the largest value of type long double is %.3Le\n&quot;, LDBL_MAX);
    
    printf (&quot;\n Variables of type float provide %u decimal digits precision. \n&quot;, FLT_DIG);
    printf (&quot;Variables of type double provide %u decimal digits precision. \n&quot;, DBL_DIG);
    printf (&quot;Variables of type long double provide %u decimal digits precision. \n&quot;,LDBL_DIG);

    return 0;
}
</code></pre>
<p>在一系列的printf()函数调用中,输出&lt;limits.h&gt;和&lt;float.h&gt;头文件定义的符号的值。计算机中的数值总是受限于该机器可以存储的值域,这些符号的值表示每种数值类型的极限值。这里用说明符 %u 输出无符号整数值。如果用 %d 输出无符号类型的最大值,则最左边的位(带符号类型的符号位)为 1 的数值就得不到正确的解释。</p>
<p>对浮点数的极限值使用说明符 %e,表示这个数值是指数形式。同时指定精确到小数点后的 3 位数,因为这里的输出不需要非常精确。print()函数显示的值是 long double类型时,需要使用 L 修饰符。L 必须是大写,这里没有使用小写字母 l。%f说明符表示没有指数的数值,它对于非常大或非常小的数来说相当不方便。在这个例子中试一试,就会明白其含义。</p>
<h5>2.8.2  sizeof运算符</h5>
<p>使用 sizeof 运算符可以确定给定的类型占据多少字节。当然,在 C 语言中 sizeof 是一个关键字。表达式 sizeof(int) 会得到int类型的变量所占的字节数,所得的值是一个size_t类型的整数。size_t 类型在标准头文件&lt;stddef.h&gt; (和其他头文件)中定义,对应于一个基本整数类型。但是,与 size_t类型对应的类型可能在不同的 C 库中有所不同,所以最好使用 size_t 变量存储 sizeof 运算符生成的值,即使知道它对应的基本类型,也应如此。下面的语句是存储用 sizeof 运算符计算所得的数值:</p>
<pre><code>size_t size = sizeof(long long);
</code></pre>
<p>也可以将 sizeof 运算符用于表达式,其结果是表达式的计算结果所占据的字节数。通常该表达式是某种类型的变量。除了确定某个基本类型的值占用的内存空间之外, sizeof 运算符还有其他用途,但这里只使用它确定每种类型占用的字节数。</p>
<pre><code>#include &lt;stdio.h&gt;// For command line input and output
int main(void) {

    printf (&quot;Variables of type  long long occupy %u butes. \n&quot;,sizef(long long));
    printf (&quot;Variables of type  float occupy %u butes. \n&quot;,sizef(float));
    printf (&quot;Variables of type  double occupy %u butes. \n&quot;,sizef(double));

    return 0;
}
</code></pre>
<p>因为 sizeof 运算符的结果是一个无符号整数,所以用 %u 说明符输出它。注意,使用表达式 sizeof var_name 也可以得到变量 var-name 占用的字节数。显然,在关键字 sizeof 和变量名之间的空格是必不可少的。</p>
<p>现在已经知道编译器给每个数值类型指定的极限值和占用的字节数了。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>    如果希望把 sizeof 运算符应用于一个类型,则该类型名必须放在括号中,例如sizeof(long double),将 sizeof 运算符应用于表达式时,括号就是可选的。</p>
</blockquote>
<h5>2.9  选择正确的类型</h5>
<p>必须仔细选择在计算过程中使用的变量类型,使之能包含我们期望的值。如果使用了错误的类型,程序就可能出现很难检测出来的错误。具体每类类型存储数值的区间如下：</p>
<p><img src="https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/1-1403161Z633114.png" alt="image" /></p>
<table>
<thead>
<tr><th>类型名称</th><th>占字节数</th><th>其他叫法</th><th>表示的数据范围</th><th>无符号</th></tr>
</thead>
<tbody>
<tr><td>char</td><td>1</td><td>signed char</td><td>-128 ~ 127</td><td>0 ~ 255</td></tr>
<tr><td>int</td><td>4</td><td>signed int</td><td>-2,147,483,648 ~ 2,147,483,647</td><td>0 ~ 4,294,967,295</td></tr>
<tr><td>short</td><td>2</td><td>short int</td><td>-32,768 ~ 32,767</td><td>0 ~ 65,535</td></tr>
<tr><td>long</td><td>4</td><td>long int</td><td>-2,147,483,648 ~ 2,147,483,647</td><td>0 ~ 4,294,967,295</td></tr>
<tr><td>long long</td><td>8</td><td>long	long int</td><td>-4,294,967,296 ~ 4,294,967,296</td><td>0 ~ 8,589,934,592</td></tr>
<tr><td>float</td><td>4</td><td>none</td><td>3.4E +/- 38 (7 digits)</td><td></td></tr>
<tr><td>double</td><td>8</td><td>none</td><td>1.7E +/- 308 (15 digits)</td><td></td></tr>
<tr><td>long double</td><td>10</td><td>none</td><td>1.2E +/- 4932 (19 digits)</td><td></td></tr>
</tbody>
</table>
<p>这里有一个编程宗旨，就是能用小不用大。</p>
<p>可以利用自动类型转换。</p>
<h5>2.10  强制类型转换</h5>
<p>将一种类型显式转换为另一种类型的过程称为强制类型转换(cast)。</p>
<pre><code>    double c;
    int d = 5;
    int e = 8;
    c = (double)(d + e) / 2;

</code></pre>
<p>将 (d + e) 的计算结果转换为 double，确保了结果的精确。</p>
<h5>2.10.1  自动转换类型</h5>
<p>二元运算符要求其操作数有相同的类型。编译器在处理涉及不同类型的值操作时,会自动把其中一个操作数的类型转换为另一个操作数的类型。在二元算术运算中使用不同类型的操作数,编译器就会把其中一个值域较小的操作数类型转换为另个操作数的类型,这称为隐式类型转换(implicit conversion)。再看看前面计算收入的表达式：</p>
<h5>2.10.2  隐式类型转换的规则</h5>
<ul>
<li>算术运算式中，低类型转换为高类型</li>
<li>赋值表达式中，表达式的值转换为左边变量的类型</li>
<li>函数调用时，实参转换为形参的类型</li>
<li>函数返回值，return表达式转换为返回值类型</li>
</ul>

</div>