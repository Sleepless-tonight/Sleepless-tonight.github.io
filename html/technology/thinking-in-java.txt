标题：thinking-in-java

标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架
时间：2018年7月17日19:20:24
连接：http://www.nostyling.cn/html/technology/thinking-in-java.txt

(1) 第1章：对象入门
    面向对象编程（OOP）
        1.1 抽象的进步
            所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。) 同一类所有对象都能接收相同的消息。

        1.2 对象的接口
            我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做那些事情。

        1.3 实现方案的隐藏
            “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员

        1.4 方案的重复使用
            为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。
            新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。
            轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。，首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。

        1.5 继承：重新使用接口
            在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。
            1.5.1 改善基础类
                改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。
                继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；

        1.6 多形对象的互换使用
            通常，继承最终会以创建一系列类收场，所有类都建立在统一的接口基础上。
            对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。
            把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。
            1.6.1 动态绑定
                将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。
            1.6.2 抽象的基础类和接口
                设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。
                亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。
                interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。

        1.7 对象的创建和存在时间
            从技术角度说，OOP（面向对象程序设计）只是涉及抽象的数据类型、继承以及多形性，但另一些问题也可能显得非常重要。
            最重要的问题之一是对象的创建及破坏方式。对象需要的数据位于哪儿，及对象的“存在时间”。

            1.7.1 集合与继承器
                “继续器”（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。它存在于所有集合中
                不同的集合在进行特定操作时往往有不同的效率。
            1.7.2 单根结构
                所有类最终是从单独一个基础类继承。他们最终都属于相同的类型。
                所有对象都在内存堆中创建，可以极大简化参数的传递。
                可以更方便地实现一个垃圾收集器。
                由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；
            1.7.3 集合库与方便使用集合
                为了使这些集合能够重复使用，或者“再生”，Java提供了一种通用类型，以前曾把它叫作“Object”。所以容纳了Object的一个集合实际可以容纳任何东西。这使我们对它的重复使用变得非常简便。
                但由于集合只能容纳Object，所以在我们向集合里添加对象句柄时，它会上溯造型成Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object句柄，而非指向我们早先置入的那个类型的句柄。
                （↑↑↑↑↑解释上面两个段落：为了复用将集合元素的类型设置为Object，当向集合中添加元素的时候会因为 Upcasting 而丢失 元素的实际类型，以至于无法调用元素的实际有用接口）
                我们再次用到了造型（Cast）。下溯造型成一种更“特殊”的类型。这种造型方法叫作“下溯造型”（Downcasting）。
                在从一个集合提取对象句柄时，必须用某种方式准确地记住它们是什么，以保证下溯造型的正确进行。
                我们可以采用“参数化类型”。
                （↑↑↑↑↑解释上面段落：集合泛型的原因）

            1.7.4 清除时的困境：由谁负责清除？
                每个对象都要求资源才能“生存”，其中最令人注目的资源是内存。如果不再需要使用一个对象，就必须将其清除，以便释放这些资源，以便其他对象使用。
                问题1：如何才能知道什么时间删除对象呢？
                    垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。

                2.垃圾收集器对效率及灵活性的影响
                    代价就是运行期的开销。
                    我们不能确定它什么时候启动或者要花多长的时间。这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它——比如在一个程序的执行必须保持稳定、连贯的时候。

        1.8 违例控制：解决错误
            错误必然发生
            它们严重依赖程序员的警觉性
            “违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。这“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。
            违例不能被忽略，“掷”出的一个违例不同于从函数返回的错误值，那些错误值或标志的作用是指示一个错误状态，是可以忽略的。
            注意违例控制并不属于一种面向对象的特性

        1.9 多线程
            在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。
            要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。
            最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。
            从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。
            一个问题：临界资源！一些支持共享，不支持并行的资源，需要在线程使用期间必须进入锁定状态。（比如“屏幕”是个共享资源，但是不能同时播放两个画面。）
            Java中对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized关键字。

        1.10 永久性
            Java8移除永久代


        1.11 Java和因特网

        1.12 分析和设计
            (1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？）
            (2) 它们的接口是什么？（需要将什么消息发给每一个对象？）

            整个过程可划分为四个阶段：
                阶段0：拟出一个计划、
                阶段1：要制作什么？
                    在上一代程序设计中（即“过程化或程序化设计”），这个阶段称为“建立需求分析和系统规格”。
                    最有价值的工具就是一个名为“使用条件”的集合。
                阶段2：如何构建？
                    此时可考虑采用一种特殊的图表工具：“统一建模语言”（UML）。
                    包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。
                阶段3：开始创建

                阶段4：校订

        1.13 Java还是C++


(2) 第2章：一切都是对象
    Java语言首先便假定了我们只希望进行面向对象的程序设计。

        2.1 用句柄操纵对象
            将一切都“看作”对象，操纵的 标识符 实际是指向一个对象的“句柄”（Handle）。
            创建一个String句柄：
                String s;
                这里创建的只是句柄，并不是对象。s实际并未与任何东西连接（即“没有实体”）。
                一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：
                String s = "asdf";

        2.2 所有对象都必须创建
            创建句柄时，我们希望它同一个新对象连接。通常用new关键字达到这一目的。。new的意思是：“把我变成这些对象的一种新实体”。

            2.2.1 保存到什么地方
                程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：

                (1) 寄存器：
                    位于处理器内部。这是最快的保存区域。
                    以寄存器是根据需要由编译器分配。
                    我们对此没有直接的控制权。
                (2) 堆栈（stack）：
                    驻留于常规RAM（随机访问存储器）区域，这是一种特别快、特别有效的数据保存方式，仅次于寄存器。
                    创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性。
                    有些Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中。
                (3) 堆（Heap）：
                    一种常规用途的内存池（也在RAM区域），在堆里分配存储空间时会花掉更长的时间！
                    编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。
                    保存了Java对象。
                (4) 静态存储 ：
                    这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。
                    程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。
                    Java对象本身永远都不会置入静态存储空间。
                (5) 常数存储 ：
                    常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
                (6) 非RAM存储 ：
                    若数据完全独立于一个程序之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。

            2.2.2 特殊情况：主要类型
                有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java采纳了与C和C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。

                Java决定了每种主要类型的大小。
                主类型     大小      封装器类型
                boolean     1-bit    Boolean
                char        16-bit   Character
                byte        8-bit    Byte[11]
                short       16-bit   Short1
                int         32-bit   Integer
                long        64-bit   Long
                float       32-bit   Float
                double      64-bit   Double

                （注意：若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。）
                1. 高精度数字
                    用于进行高精度的计算：BigInteger和BigDecimal。尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。

            2.2.3 Java的数组
                Java的一项主要设计目标就是安全性。一个Java可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。
                创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的关键字：null（空）。一旦Java看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。

        2.2 所有对象都必须创建
            在大多数程序设计语言中，变量的“存在时间”（Lifetime）一直是程序员需要着重考虑的问题。变量应持续多长的时间？如果想清除它，那么何时进行？在变量存在时间上纠缠不清会造成大量的程序错误。

            2.3.1 作用域（Scope）
                作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。
                例子：
                    {
                    int x = 12;
                    /* only x available */
                    {
                    int q = 96;
                    /* both x & q available */
                    }
                    /* only x available */
                    /* q “out of scope” */
                    }
                作为在作用域里定义的一个变量，它只有在那个作用域结束之前才可使用。

            2.3.2 对象的作用域
                Java对象不具备与主类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。
                例子：
                    {
                    String s = new String("a string");
                    } /* 作用域的终点 */
                那么句柄s会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。
                这样造成的结果便是：对于用new创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。看来在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且更麻烦的是，在C++里，一旦工作完成，必须保证将对象清除。
                假如Java让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在C++里，这个问题最令程序员头痛。但Java以后，情况却发生了改观。Java有一个特别的“垃圾收集器”，它会查找用new创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。

        2.4 新建数据类型：类
            一切东西都是对象，那么用什么决定一个“类”（Class）的外观与行为呢？换句话说，是什么建立起了一个对象的“类型”（class）呢？通过 class 关键字。
            例如：
                这样就引入了一种新类型。
                    class ATypeName {/*类主体置于这里}

                这样就用new创建这种类型的一个新对象：
                    ATypeName a = new ATypeName();

            2.4.1 字段和方法
                定义一个类时（我们在Java里的全部工作就是定义类、制作那些类的对象以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）、成员函数（通常叫“方法”）。其中，数据成员是一种对象（通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄）之一。如果是指向对象的一个句柄，则必须初始化那个句柄，用一种名为“构建器”的特殊函数将其与一个实际对象连接起来（就象早先看到的那样，使用new关键字）。但若是一种主类型，则可在类定义位置直接初始化（正如后面会看到的那样，句柄亦可在定义位置初始化）。
                每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。（这个共享是指指向一块内存位置的意思么？）
                示例：
                    class DataOnly {
                    int i;
                    float f;
                    boolean b;
                    }
                对象实例化后可值赋给数据成员，但首先必须知道如何引用一个对象的成员。首先要写上对象句柄的名字，再跟随一个点号，再跟随对象内部成员的名字。即“对象句柄.成员”。(引用 或者 说 访问权限 会受 修饰符（public、protected、default、private）影响。)
                例如：
                    d.i = 47;
                    d.f = 1.1f;
                    d.b = false;
                一个对象也可能包含了另一个对象，只需保持“连接句点”即可。
                例如：
                    myPlane.leftTank.capacity = 100;

                1. 主成员的默认值：
                    若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值（自动初始化）。
                    主类型 默认值：
                        Boolean false
                        Char '\u0000'(null)
                        byte (byte)0
                        short (short)0
                        int 0
                        long 0L
                        float 0.0f
                        double 0.0d

                    注意：
                        若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。

        2.5 方法、自变量和返回值
            我们一直用“函数”（Function）这个词指代一个已命名的子例程。但在Java里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。尽管它们表达的实际是同一个意思。
            Java的“方法”决定了一个对象能够接收的消息。
            方法的基本组成部分包括名字、自变量、返回类型以及主体。下面便是它最基本的形式：
                返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */}

            返回类型是指调用方法之后返回的数值类型。显然，方法名的作用是对具体的方法进行标识和引用。自变量列表列出了想传递给方法的信息类型和名称。
            Java的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（注释③），而且那个对象必须能够执行那个方法调用。

            为一个对象调用方法时，需要先列出对象的名字，在后面跟上一个句点，再跟上方法名以及它的参数列表。亦即“对象名.方法名(自变量1，自变量2，自变量3...)。例如：我们有一个方法名叫f()，它没有自变量，返回的是类型为int的一个值。假设有一个名为a的对象，可为其调用方法f()，则代码如下：
                int x = a.f();

            象这样调用一个方法的行动通常叫作“向对象发送一条消息”。在上面的例子中，消息是f()，而对象是a。面向对象的程序设计通常简单地归纳为“向对象发送消息”。
            ③：正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象。

            2.5.1 自变量列表
                自变量列表规定了我们传送给方法的是什么信息。这些信息——如同Java内其他任何东西——采用的都是对象的形式。因此，我们必须在自变量列表里指定要传递的对象类型，以及每个对象的名字。正如在Java其他地方处理对象时一样，我们实际传递的是“句柄”（注释④）。然而，句柄的类型必须正确。倘若希望自变量是一个“字串”，那么传递的必须是一个字串。
                ④：对于前面提及的“特殊”数据类型boolean，char，byte，short，int，long，，float以及double来说是一个例外。但在传递对象时，通常都是指传递指向对象的句柄。（也就是说 基本类型 传递的是值本身）
                return 关键字的运用。它主要做两件事情。首先，它意味着“离开方法，我已完工了”。其次，假设方法生成了一个值，则那个值紧接在return语句的后面。可按返回 那个值，但倘若不想返回任何东西，就可指示方法返回void（空）。
                若返回类型为void，则return关键字唯一的作用就是退出方法。
                但假设已指定了一种非void的返回类型，那么无论从何地返回，编译器都会确保我们返回的是正确的类型。

        2.6 构建Java程序































(3) 第3章：控制程序流程
(4) 第4章：初始化和清除
(5) 第5章：隐藏实现过程
(6) 第6章：类再生
(7) 第7章：多形性
(8) 第8章：对象的容纳
(9) 第9章：违例差错控制
(10) 第10章：Java IO系统
(11) 第11章：运行期类型鉴定
(12) 第12章：传递和返回对象
(13) 第13章：创建窗口和程序片
(14) 第14章：多线程
(15) 第15章 网络编程
(16) 第16章 设计范式
(17) 第17章 项目
(18) 附录A：使用非Java代码
(19) 附录B：对比C++和Java
(20) 附录C：Java编程规则
(21) 附录D：性能
(22) 附录E：关于垃圾收集的一些话
(23) 附录F：推荐读物



