# Beginning C ,Fifth Edition

## 第6章：字符串和文本的应用
本章将探讨如何使用字符数组,以扩展数组知识。我们经常需要将文本字符串用作个实体,不过C语言没有提供字符串数据类型,而是使用char类型的数组元素存储字符串。本章将介绍如何创建和处理字符串变量,标准库函数如何简化字符串的处理。

**本章的主要内容:**
- 如何创建字符串变量
- 如何连接两个或多个字符串,形成一个字符串
- 如何比较字符串
- 如何使用字符串数组
- 哪些库函数能处理字符串,如何应用它们


### 6.1 什么是字符串
字符串常量的例子非常常见。字符串常量是放在一对双引号中的一串字符或符号。一对双引号之间的任何内容都会被编译器视为字符串,包括特殊字符和嵌入的空格。每次使用printr)显示信息时,就将该信息定义成字符串常量了。以下的语句是用这种方法使用字符串的例子:
```
printf ("This is a string.");
printf ("This is on\ntwo lines!");
printf ("For \" you write \\\".");
```
这3个字符串例子如图6-1所示。存储在内存中的字符码的十进制值显示在这些字符的下方。

第一个字符串是一系列字符后跟一个句号。printf()函数会把这个字符串输出为:
```
This is a string.
```
第二个字符串有一个换行符\n,所以字符串显示在两行上:
```
This is on
two lines!
```
·第三个字符串有点难以理解,但print()函数的输出很清楚:
```
For " you write \".
```
![image](https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2021-01-29_135432.png)
必须把字符串中的双引号写为转义序列\",因为编译器会把双引号看作字符串的结尾。要在字符串中包含反斜杠,也必须使用转义序列\\,因为字符串中的反斜杠总是表示转义序列的开头。

如图6-1所示,每个字符串的末尾都添加了代码值为0的特殊字符,这个字符称为空字符,写为\0。C中的字符串总是由\0字符结束,所以字符串的长度永远比字符串中的字符数多1。

> 注意
> > 空字符不要和 NULL 混淆。空字符是字符串的终止符,而 NULL 是一个符号,表示不引用任何内容的内存地址。

可以自己将 \0 字符添加到字符串的结尾,但是这会使字符串的末尾有两个\0字符。下面的程序说明了空字符是如何运作的:
```
#include <stdio.h>
int main(void){
    printf ("This is a \0 string.");
    return 0;
}
```
编译并执行这个程序,会得到如下输出:
```
This is a
```
这可不是我们期望的结果:仅显示了字符串的第一部分。这个程序显示了前两个字符后就结束输出,是因为print()函数遇到第一个空字符 \0 时,就会停止输出。即使在字符串的末尾还有另一个 \0,也永远不会执行它。在遇到第一个 \0 时,就表示字符串结束了。


### 6.2 存储字符串的变量
C语言对变量存储字符串的语法没有特殊的规定,而且C根本就没有字符串变量,也没有处理字符串的特殊运算符。但这不成问题,因为标准库提供了许多函数来处理字符串,下面先看看如何创建表示字符串的变量。

如本章开头所述,可以使用char类型的数组保存字符串。这是字符串变量的最简单式。char数组变量的声明如下:
```
char saying[20];
```
这个变量可以存储一个至多包含19个字符的字符串,因为必须给终止字符提供一个数组元素。当然也可以使用这个数组存储20个字符,那就不是一个字符串了。


> 警告
> > 声明存储字符串的数组时,其大小至少要比所存储的字符数多1,因为编译器会自动在字符串常量的末尾添加 \0。

也可以用以下的声明初始化前面的字符串变量:
```
char saying[] ="This is a string.";
```
这里没有明确定义这个数组的大小。编译器会指定一个足以容纳这个初始化字符串常量的数值。在这个例子中它是18,其中17个元素用于存储字符串中的字符,再加上一个额外的终止字符 \0。当然可以指定这个数值,但是如果让编译器指定,可以确保它一定正确。

也可以用一个字符串初始化char类型数组的部分元素,例如:
```
char saying[40] ="To be";
```
这里编译器会使用指定字符串的字符初始化从str0]到str[4]的前5个元素,而str[5]含有空字符\0。当然,数组的所有40个元素都会被分配空间,可以以任意方式使用。初始化一个char数组,将它声明为常量,是处理标准信息的好方法:
```
const char message[] ="This is a string.";
```
将 message 声明成常量,它就不会在程序中被显式更改。只要试图更改它,编译器都会产生错误信息。当标准信息在程序中的许多地方使用时,这种定义标准信息的方法特别有用。它可以防止在程序的其他部分意外地修改这种常量。当然,假使必须改变这条信息,就不应将它指定为const。

要引用存储在数组中的字符串时,只需使用数组名即可。例如,如果要用print()函数输出存储在 message 中的字符串,可以编写:
```
printf ("The message is:%s",message);
```
这个 %s 说明符用于输出一个用空字符终止的字符串。函数printf()会在第一个参数的 %s 位置,输出 message 数组中连续的字符,直到遇到 \0 字符为止。当然, char数组的执行方式与其他类型的数组一样,所以可以用相同的方式使用它。字符串处理函数唯需要特别考虑的是 \0 字符,所以从外表看来,包含字符串的数组没有什么特别的。

使用char数组存储许多不同的字符串时,必须用足以容纳要存储的最大字符串长度来声明数组的大小。在大多数情况下,一般的字符串都会小于这个最大值,所以确定字符串的长度是很重要的,特别是要给字符串添加更多的字符。下面用一个例子来说明:
```
#include <stdio.h>

int main(void) {
    char str1[] = "To be or not to be";
    char str2[] = ",that is the question";
    unsigned int count = 0;
    while (str1[count] != '\0') {
        ++count;
    }

    printf("The length of the string \"%s\" is %d characters.\n", str1, count);
    count = 0;
    while (str2[count] != '\0') {
        ++count;
    }
    printf("The length of the string \"%s\" is %d characters.\n", str2, count);

    return 0;
}
```


#### 字符串的多维数组
可以使用char类型的二维数组存储字符串,数组的每一行都用来存储一个字符串。这样,就可以存储一整串字符串,通过一个变量名来引用它们,例如:
```
char sayings [3][32] = {
"Manners markth man.",
"Many hands make lightwork.",
"Manners markth man."
}
```
这条语句创建了一个数组,它包含3行,每行32个字符。括号中的字符串按顺序指定数组的3行sayings[0]、 sayings[1]和sayings[3]。注意,不需要用括号将每个字符串括起来。编译器能推断出每个字符串初始化数组的一行。第一维指定数组可以包含的字符串个数,第二维指定为32,刚好能容纳最长的字符串(包含\0终止字符)。

在引用数组的元素时,例如sayings[i][j],第一个索引i指定数组中的行,第二个索引j指定该行中的一个字符。要引用数组中包含一个字符串的一整行,只需在方括号中包含一个索引值。例如sayings[1]引用数组的第二个字符串, "Many hands make lightwork."。

在字符串数组中,必须指定第二维的大小,也可以让编译器计算数组有多少个字符串。上述定义可以写为:
```
char sayings [][32] = {
"Manners markth man.",
"Many hands make lightwork.",
"Manners markth man."
}
```
因为有3个初始字符串,编译器会将数组的第一维大小指定为3。当然,还必须确保第二维的空间足以容纳最长的字符串,包含终止字符。


### 6.3 字符串操作
上例说明了确定字符串长度的代码,但其实并不需要编写这样的代码。标准库提供了一个执行该操作的函数,和许多处理字符串的其他函数。要使用它们,必须把string.h头文件包含在源文件中。

后面面向任务的章节主要介绍C11标准引入的新字符串函数,它们比以前习惯使用的传统函数更安全、更健壮,它们提供了更强大的保护,可以防止出现缓存溢出等错误。但是,这个保护依赖仔细而正确的编码。

#### 6.3.1 检查对C11的支持
标准库提供的字符串处理函数默认集合并不安全。它们使代码包含错误的可能性很大,有时这些错误很难查找。一个较大的问题是在网络环境下使用时,它们允许恶意代码破坏程序。这些问题发生的主要原因是,无法验证数组有足够的空间执行操作。因此,C11标准包含字符串处理函数的可选版本,它们更安全、更不容易出错,因为它们会检查数组的维数,确保它们足够大。编写安全、不易出错的代码非常重要,所以这里主要介绍对数组进行边界检查的可选字符串处理函数。在我看来,任何遵循C11的编译器都应实现这些可选的字符串函数。所有的可选函数名都以s结尾。

很容易确定C编译器附带的标准库是否支持这些可选函数。只需要编译并执行如下代码:
```
#include <stdio.h>

int main(void) {
#if defined __STDC_LIB_EXT1__
    printf("P1\n");
#else
    printf("P2\n");
#endif
    return 0;
}

```
根据C11标准实现可选函数的编译器,会定义 __STDC_LIB_EXT1__ 符号。这段代码使用预处理器指令,根据是否定义了 __STDC_LIB_EXT1__ 符号,插入两个printf()语句中的一个。如果定义了这个符号,代码就输出消息:
```
P1
```
如果没有定义 __STDC_LIB_EXT1__ 符号,代码就输出消息:
```
P2
```
这里使用的预处理器指令(它们是以#开头的代码行)采用与if语句相同的执行方式。第13章将详细介绍预处理器指令。

要使用string.h中的可选函数,必须在string.h的include语句之前,在源文件中定义 __STDC_LIB_EXT1__ 符号,来表示值1,如下所示: #define  __STDC_LIB_EXT1__ 1// Make optional versions of functions available
```
 #define  __STDC_LIB_EXT1__ 1// Make optional versions of functions available
 #include <string.h>
```
如果没有把这个符号定义为1,就只能使用字符串处理函数的标准集合。为什么需要这个精巧的机制,才能使用可选函数?原因是它不会中断推出C11标准之前编写的旧代码。显然,旧代码可能使用了一个或多个新函数名。尤其是,许多程序员以前都实现了自己的、更安全的字符串处理函数,这样就很容易与C11库产生名称冲突。出现这种冲突时,把  __STDC_LIB_EXT1__  定义为0,禁止使用可选函数,旧代码就可以用C11编译器编译了。

#### 6.3.2 确定字符串的长度

strnlen_s()函数返回字符串的长度,它需要两个参数:字符串的地址(这是一维char数组的数组名)和数组的大小。知道数组的大小,若字符串没有结尾的\0字符,函数就可以避免访问最后一个元素后面的内存。

该函数把字符串的长度返回为一个size_t类型的整数值。如果第一个参数是NULL,就返回0。如果在第二个参数值的元素个数中,第一个参数指定的数组不包含\0字符,就返回第二个参数值,作为字符串的长度。
```
#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>
#include <string.h>

int main(void) {

    char s[] = "test";

    printf("test:%zu", strnlen(s, sizeof(s)));
    return 0;
}

```

> 注意
> > 确定字符串长度的标准函数是strlen(),它只把字符串的地址作为参数。若字符串没有10,这个函数会越过字符串的末尾。


#### 6.3.3 复制字符串

strcpy_s()函数可以把一个字符串变量的内容赋予另一个字符串。它的第一个参数指定复制目标,第二个参数是一个整数,指定第一个参数的大小,第三个参数是源字符串。指定目标字符串的长度,可以使函数避免覆盖目标字符串中最后一个字符后面的内存。如果源字符串比目标字符串长,就会发生这种情形。如果一切正常,该函数就返回0,否则就返回非0整数值。下面是一个示例:
```
#define __STDC_WANT_LIB_EXT1__ 1

#include <stdio.h>
#include <string.h>

int main(void) {

    char s[] = "test";
    char s2[10];
    unsigned int max = 3;
    strncpy_s(s2, sizeof(s2), s,3);
    printf("tes:%s.", s2);
    printf("test:%zu", strnlen(s2, sizeof(s2)));
    return 0;
}
```
strncpy_s() 函数可以把源字符串的一部分复制到目标字符串中。在strcpy_s()函数名中添加n表示,可以至多复制指定的n个字符。前三个参数与strcpy_s()相同,第四个参数指定从第三个参数指定的源字符串中复制的最大字符数。如果在复制指定的最大字符数之前,在源字符串中找到了\0,复制就停止,并把\0添加到目标字符串的末尾。



#### 6.3.4 连接字符串
连接是把一个字符串连接到另一个字符串的尾部,这是很常见的需求。例如,把两个或多个字符串合成为一条信息。在程序中,将错误信息定义为几个基本的文本字符串,然后给它们添加另一个字符串,使之变成针对某个错误的信息。

把一个字符串复制到另一个字符串的末尾时,需要确保操作是否安全的两个方面:第一,目标字符串的可用空间是否足够,不会覆盖其他数据,甚或代码;第二,连接得到的字符串末尾有、0字符。string.h中的可选函数strcat_s()满足这些要求。

strcat_s()函数需要三个参数:要添加新字符串的字符串地址,第一个参数可以存储的最大字符串长度,要添加到第一个参数中的字符串地址。该函数把一个整数错误码返回为erno_t类型的值,它是一个取决于编译器的整数类型。
```
#define __STDC_WANT_LIB_EXT1__ 1

#include <stdio.h>
#include <string.h>

int main(void) {
    char str1[50] = "to be, or not to be,";
    char str2[] = "that is question.";
    int retval = strcat_s(str1, sizeof(str1), str2);
    printf("str1:%s\n", str1);

    char s[] = "test";
    char s2[10];
    unsigned int max = 3;
    strncpy_s(s2, sizeof(s2), s,3);
    printf("tes:%s.", s2);
    printf("test:%zu", strnlen(s2, sizeof(s2)));
    return 0;
}
```
字符串strl和strl连接在一起,所以这个代码段使用strcat s()把str2追加到strl上。该操作把str2复制到strl的末尾,覆盖strl中的0,再在最后添加一个1。如果一切正常,strcat s)就返回0。如果strl不够大,不能追加str2,或者有其他条件禁止该操作正确执行,返回值就非0

与strncpy_s()一样,可选函数strncat_s()把一个字符串的一部分连接到另一个字符串上。它也有一个额外的参数,指定要连接的最大字符数。下面是其工作方式:


> 警告
> > 不能把字符串连接到不包含字符串的数组中。如果希望使用strcats()或strncat_s()把preamble复制到joke中,就需要把joke初始化为空字符串。数组的维数在运行期间确定时,编译器就不允许在声明语句中初始化数组。要把joke初始化为空数组,可以使用赋值语句在joke[0]中存储



> 注意
> > 终止程序时返回的任何非0值都表示异常。给异常使用不同的非0值,可以表示代"码中出现了异常。




#### 6.3.5 比较字符串

字符串库提供的函数还可以比较字符串,确定一个字符串是大于还是小于另一个字符串。字符串使用“大于”和“小于”这样的术语听起来有点奇怪,但是其结果相当简单。两个字符串的比较是基于它们的字符码,如图6-2所示,图中的字符码显示为十六进制数。

如果两个字符串是相同的,它们就是相等的。要确定第一个字符串是小于还是大于第二个字符串,应比较两个字符串中第一对不同的字符。例如,如果第一个字符串中某字符的字符码小于第二个字符串中的对应字符,第一个字符串就小于第二个字符串。以字母次序安排字符串时,这种比较机制一般符合我们的预期。



#### 6.3.6 搜索字符串

头文件<string.h>声明了几个字符串搜索函数,但是在探讨它们之前,先了解下一章的主题-指针,这里需要这些基础知识,以理解如何使用字符串搜索函数。

##### 1. 指针的概念












