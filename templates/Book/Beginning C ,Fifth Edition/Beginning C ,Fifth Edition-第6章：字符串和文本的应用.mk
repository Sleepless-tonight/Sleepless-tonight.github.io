# Beginning C ,Fifth Edition

## 第6章：字符串和文本的应用
本章将探讨如何使用字符数组,以扩展数组知识。我们经常需要将文本字符串用作个实体,不过C语言没有提供字符串数据类型,而是使用char类型的数组元素存储字符串。本章将介绍如何创建和处理字符串变量,标准库函数如何简化字符串的处理。

**本章的主要内容:**
- 如何创建字符串变量
- 如何连接两个或多个字符串,形成一个字符串
- 如何比较字符串
- 如何使用字符串数组
- 哪些库函数能处理字符串,如何应用它们


### 6.1 什么是字符串
字符串常量的例子非常常见。字符串常量是放在一对双引号中的一串字符或符号。一对双引号之间的任何内容都会被编译器视为字符串,包括特殊字符和嵌入的空格。每次使用printr)显示信息时,就将该信息定义成字符串常量了。以下的语句是用这种方法使用字符串的例子:
```
printf ("This is a string.");
printf ("This is on\ntwo lines!");
printf ("For \" you write \\\".");
```
这3个字符串例子如图6-1所示。存储在内存中的字符码的十进制值显示在这些字符的下方。

第一个字符串是一系列字符后跟一个句号。printf()函数会把这个字符串输出为:
```
This is a string.
```
第二个字符串有一个换行符\n,所以字符串显示在两行上:
```
This is on
two lines!
```
·第三个字符串有点难以理解,但print()函数的输出很清楚:
```
For " you write \".
```
![image](https://nostyling-1256016577.cos.ap-beijing.myqcloud.com/2021-01-29_135432.png)
必须把字符串中的双引号写为转义序列\",因为编译器会把双引号看作字符串的结尾。要在字符串中包含反斜杠,也必须使用转义序列\\,因为字符串中的反斜杠总是表示转义序列的开头。

如图6-1所示,每个字符串的末尾都添加了代码值为0的特殊字符,这个字符称为空字符,写为\0。C中的字符串总是由\0字符结束,所以字符串的长度永远比字符串中的字符数多1。

> 注意
> > 空字符不要和 NULL 混淆。空字符是字符串的终止符,而 NULL 是一个符号,表示不引用任何内容的内存地址。

可以自己将 \0 字符添加到字符串的结尾,但是这会使字符串的末尾有两个\0字符。下面的程序说明了空字符是如何运作的:
```
#include <stdio.h>
int main(void){
    printf ("This is a \0 string.");
    return 0;
}
```
编译并执行这个程序,会得到如下输出:
```
This is a
```
这可不是我们期望的结果:仅显示了字符串的第一部分。这个程序显示了前两个字符后就结束输出,是因为print()函数遇到第一个空字符 \0 时,就会停止输出。即使在字符串的末尾还有另一个 \0,也永远不会执行它。在遇到第一个 \0 时,就表示字符串结束了。


### 6.2 存储字符串的变量
C语言对变量存储字符串的语法没有特殊的规定,而且C根本就没有字符串变量,也没有处理字符串的特殊运算符。但这不成问题,因为标准库提供了许多函数来处理字符串,下面先看看如何创建表示字符串的变量。

如本章开头所述,可以使用char类型的数组保存字符串。这是字符串变量的最简单式。char数组变量的声明如下:
```
char saying[20];
```
这个变量可以存储一个至多包含19个字符的字符串,因为必须给终止字符提供一个数组元素。当然也可以使用这个数组存储20个字符,那就不是一个字符串了。


> 警告
> > 声明存储字符串的数组时,其大小至少要比所存储的字符数多1,因为编译器会自动在字符串常量的末尾添加 \0。

也可以用以下的声明初始化前面的字符串变量:
```
char saying[] ="This is a string.";
```
这里没有明确定义这个数组的大小。编译器会指定一个足以容纳这个初始化字符串常量的数值。在这个例子中它是18,其中17个元素用于存储字符串中的字符,再加上一个额外的终止字符 \0。当然可以指定这个数值,但是如果让编译器指定,可以确保它一定正确。

也可以用一个字符串初始化char类型数组的部分元素,例如:
```
char saying[40] ="To be";
```
这里编译器会使用指定字符串的字符初始化从str0]到str[4]的前5个元素,而str[5]含有空字符\0。当然,数组的所有40个元素都会被分配空间,可以以任意方式使用。初始化一个char数组,将它声明为常量,是处理标准信息的好方法:
```
const char message[] ="This is a string.";
```
将 message 声明成常量,它就不会在程序中被显式更改。只要试图更改它,编译器都会产生错误信息。当标准信息在程序中的许多地方使用时,这种定义标准信息的方法特别有用。它可以防止在程序的其他部分意外地修改这种常量。当然,假使必须改变这条信息,就不应将它指定为const。

要引用存储在数组中的字符串时,只需使用数组名即可。例如,如果要用print()函数输出存储在 message 中的字符串,可以编写:
```
printf ("The message is:%s",message);
```
这个 %s 说明符用于输出一个用空字符终止的字符串。函数printf()会在第一个参数的 %s 位置,输出 message 数组中连续的字符,直到遇到 \0 字符为止。当然, char数组的执行方式与其他类型的数组一样,所以可以用相同的方式使用它。字符串处理函数唯需要特别考虑的是 \0 字符,所以从外表看来,包含字符串的数组没有什么特别的。

使用char数组存储许多不同的字符串时,必须用足以容纳要存储的最大字符串长度来声明数组的大小。在大多数情况下,一般的字符串都会小于这个最大值,所以确定字符串的长度是很重要的,特别是要给字符串添加更多的字符。下面用一个例子来说明:
```
#include <stdio.h>

int main(void) {
    char str1[] = "To be or not to be";
    char str2[] = ",that is the question";
    unsigned int count = 0;
    while (str1[count] != '\0') {
        ++count;
    }

    printf("The length of the string \"%s\" is %d characters.\n", str1, count);
    count = 0;
    while (str2[count] != '\0') {
        ++count;
    }
    printf("The length of the string \"%s\" is %d characters.\n", str2, count);

    return 0;
}
```


#### 字符串的多维数组
可以使用char类型的二维数组存储字符串,数组的每一行都用来存储一个字符串。这样,就可以存储一整串字符串,通过一个变量名来引用它们,例如:
```
char sayings [3][32] = {
"Manners markth man.",
"Many hands make lightwork.",
"Manners markth man."
}
```
这条语句创建了一个数组,它包含3行,每行32个字符。括号中的字符串按顺序指定数组的3行sayings[0]、 sayings[1]和sayings[3]。注意,不需要用括号将每个字符串括起来。编译器能推断出每个字符串初始化数组的一行。第一维指定数组可以包含的字符串个数,第二维指定为32,刚好能容纳最长的字符串(包含\0终止字符)。

在引用数组的元素时,例如sayings[i][j],第一个索引i指定数组中的行,第二个索引j指定该行中的一个字符。要引用数组中包含一个字符串的一整行,只需在方括号中包含一个索引值。例如sayings[1]引用数组的第二个字符串, "Many hands make lightwork."。

在字符串数组中,必须指定第二维的大小,也可以让编译器计算数组有多少个字符串。上述定义可以写为:
```
char sayings [][32] = {
"Manners markth man.",
"Many hands make lightwork.",
"Manners markth man."
}
```
因为有3个初始字符串,编译器会将数组的第一维大小指定为3。当然,还必须确保第二维的空间足以容纳最长的字符串,包含终止字符。


### 6.3 字符串操作
上例说明了确定字符串长度的代码,但其实并不需要编写这样的代码。标准库提供了一个执行该操作的函数,和许多处理字符串的其他函数。要使用它们,必须把string.h头文件包含在源文件中。

后面面向任务的章节主要介绍C11标准引入的新字符串函数,它们比以前习惯使用的传统函数更安全、更健壮,它们提供了更强大的保护,可以防止出现缓存溢出等错误。但是,这个保护依赖仔细而正确的编码。

#### 6.3.1 检查对C11的支持
标准库提供的字符串处理函数默认集合并不安全。它们使代码包含错误的可能性很大,有时这些错误很难查找。一个较大的问题是在网络环境下使用时,它们允许恶意代码破坏程序。这些问题发生的主要原因是,无法验证数组有足够的空间执行操作。因此,C11标准包含字符串处理函数的可选版本,它们更安全、更不容易出错,因为它们会检查数组的维数,确保它们足够大。编写安全、不易出错的代码非常重要,所以这里主要介绍对数组进行边界检查的可选字符串处理函数。在我看来,任何遵循C11的编译器都应实现这些可选的字符串函数。所有的可选函数名都以s结尾。

很容易确定C编译器附带的标准库是否支持这些可选函数。只需要编译并执行如下代码:
```
#include <stdio.h>

int main(void) {
#if defined __STDC_LIB_EXT1__
    printf("P1\n");
#else
    printf("P2\n");
#endif
    return 0;
}

```
根据C11标准实现可选函数的编译器,会定义 __STDC_LIB_EXT1__ 符号。这段代码使用预处理器指令,根据是否定义了 __STDC_LIB_EXT1__ 符号,插入两个printf()语句中的一个。如果定义了这个符号,代码就输出消息:
```
P1
```
如果没有定义 __STDC_LIB_EXT1__ 符号,代码就输出消息:
```
P2
```
这里使用的预处理器指令(它们是以#开头的代码行)采用与if语句相同的执行方式。第13章将详细介绍预处理器指令。

要使用string.h中的可选函数,必须在string.h的include语句之前,在源文件中定义 __STDC_LIB_EXT1__ 符号,来表示值1,如下所示: #define  __STDC_LIB_EXT1__ 1// Make optional versions of functions available
```
 #define  __STDC_LIB_EXT1__ 1// Make optional versions of functions available
 #include <string.h>
```
如果没有把这个符号定义为1,就只能使用字符串处理函数的标准集合。为什么需要这个精巧的机制,才能使用可选函数?原因是它不会中断推出C11标准之前编写的旧代码。显然,旧代码可能使用了一个或多个新函数名。尤其是,许多程序员以前都实现了自己的、更安全的字符串处理函数,这样就很容易与C11库产生名称冲突。出现这种冲突时,把  __STDC_LIB_EXT1__  定义为0,禁止使用可选函数,旧代码就可以用C11编译器编译了。

#### 6.3.2 确定字符串的长度












